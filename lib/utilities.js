var xml2js = require('xml2js');
var js2xml = new xml2js.Builder();
var crypto = require('crypto');
var request = require('request');
var url = require('url-join');
var parser = require('parse5');
var xmlserializer = require('xmlserializer');
var dom = require('xmldom').DOMParser;
var xpath = require('xpath');

var utilities = module.exports;

// Error code names from here: https://github.com/MartijnBraam/huawei-3g/blob/master/huawei_3g/huawei_e303.py
var errorCodes = {
  "100002": "No support", // Huawei branded 404
  "100003": "Access denied", // Huawei branded 403
  "100004": "Busy",
  "100005": "Unknown",
  "108001": "Wrong username",
  "108002": "Wrong password",
  "108003": "Already logged in",
  "120001": "Voice busy",
  "125001": "Wrong __RequestVerificationToken header",

  "125002": "Bad request, generic", // ??
  "125003": "Session tokens missing", // ??
  "100008": "Unknown", // ??
  "108006": "Wrong password", // ??
};



// utility function for retrieving HTML code
utilities.getUrl = function(url, token) {
    return new Promise((resolve, reject) => {
        var options = {
            url: url,
            headers: {
                'Cookie': token.cookies,
                // Avoid "Access denied" errors using a User-Agent header.
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36'
            }
        };
        request(options, (error, response, body) => {
            if (error) reject(error);
            if (response && response.statusCode != 200) {
                reject('Status code: ' + response.statusCode);
            }
            resolve(body);
        });
    });
}

/*
 * Utility action for updating the CSRF token for the respective action
 * MUST BE called every time you need to do some action
 *
 * url: Full front-end url related to the action to do, i.e.
 *      if the action is rebooting the router, the
 *      api url is "/api/device/control" and the front-end url is "/html/reboot.html"
 *      DO NOT forget to prepend the schema and IP address to the url.
 *
 * token: The token generated by router.getToken. call login() before access to restricted pages.
 */
utilities.updateToken = function(url, token, cb) {
    // Get the HTML content of the fron end page
    utilities.getUrl(url, token).then((htmlContent) => {
        // Prepare Xpath (or anything else that helps you to retrieve HTML/XML data)
        var domDocument = new dom().parseFromString(xmlserializer.serializeToString(parser.parse(htmlContent)));
        var searchXpath = xpath.useNamespaces({"x": "http://www.w3.org/1999/xhtml"});
        var newToken = searchXpath('//*/x:meta[@name="csrf_token"][1]/@content', domDocument)[0].value;

        // Update the value of token.token with the new one found in the HTML page.
        token.token = newToken;
        cb();
    });
}

utilities.parseMessages = function(messages) {
    const tMessages = [];
    messages.forEach((message) => {
        const tMessage = {};
        Object.keys(message).forEach((key) => {
            if (message[key].length  === 1) {
                tMessage[key] = message[key][0];
            }
        });
        tMessages.push(tMessage);
    });
    return tMessages;
}

utilities.getMessages = function(gateway, token, cb, messages = [], page = 1) {
    utilities.contactRouter(
        url('http://', gateway, '/api/sms/sms-list'),
        token,
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?><request><PageIndex>" + page + "</PageIndex><ReadCount>20</ReadCount><BoxType>1</BoxType><SortType>0</SortType><Ascending>0</Ascending><UnreadPreferred>0</UnreadPreferred></request>",
        function(error, response) {
            if (error) {
                cb(error, messages);
            } else {
                if (response.Count && response.Count.length > 0 && parseInt(response.Count[0]) > 0 && response.Messages && response.Messages.length > 0 && response.Messages[0].Message) {
                    messages = messages.concat(response.Messages[0].Message);
                    page++;
                    utilities.getMessages(gateway, token, cb, messages, page);
                } else {
                    cb(null, messages);
                }
            }
        }
    );
}

utilities.addZero = function(i) {
  if (i < 10) {
    i = "0" + i;
  }
  return i;
}

utilities.currentDate = function() {
    var d = new Date(),
        month = '' + (d.getMonth() + 1),
        day = '' + d.getDate(),
        year = d.getFullYear();

    if (month.length < 2)
        month = '0' + month;
    if (day.length < 2)
        day = '0' + day;

    var h = utilities.addZero(d.getHours());
    var m = utilities.addZero(d.getMinutes());
    var s = utilities.addZero(d.getSeconds());

    return [year, month, day].join('-') + " " + h + ":" + m + ":" + s;
}

utilities.contactRouter = function(uri, token, post, callback) {
  var options = {
    url: uri
  };
  if (token) {
      options.headers = {
        'Cookie': token.cookies,
        '__RequestVerificationToken': token.token,
        'DNT': '1'
    };
  }
  if (post) {
    options.method = 'POST';

    if (typeof post === "object") options.form = js2xml.buildObject({request:post});
    else options.form = post;
  }

  request(options, function(error, response, body) {
    if (error) callback(error, null);

    if (response && response.headers && response.headers['set-cookie']) token.cookies = response.headers['set-cookie'][0].split(';')[0];
    if (response && response.headers && response.headers['__requestverificationtoken']) token.token = response.headers['__requestverificationtoken'];
    // if (response.headers['__requestverificationtokenone']) token.tokenOne = response.headers['__requestverificationtokenone']
    // if (response.headers['__requestverificationtokentwo']) token.tokenTwo = response.headers['__requestverificationtokentwo']

    xml2js.parseString(body, function(error, response) {
      if (!response) {
        callback(Error("Could not contact server, no response", null));
      } else if (response.error) {
        if (errorCodes[response.error.code]) callback(errorCodes[response.error.code]);
        else callback(new Error(response.error.code + ': ' + response.error.message));
      } else {
        callback(error, response.response);
      }
    });
  });
};

utilities.prepareLogin = function(username, password, token) {
  /*
   * Note how the router wants the password to be the following:
   * 1) Hashed by SHA256, then the raw output base64 encoded.
   * 2) The username is appended with the result of the above,
   *   AND the current token. Yes, the password changes everytime
   *   depending on what token we got. This really fucks with scrapers.
   * 3) The string from above (point 2) is then hashed by SHA256 again,
   *    and the raw output is once again base64 encoded.
   *
   * This is how the router login process works. So the password being sent
   * changes everytime depending on the current user session/token.
   * Not bad actually.
   */
  var hashedPassword = SHA256andBase64(
    SHA256andBase64(password) + username + token
  ).toString();

  var login = {
    request: {
      username: username,
      password: hashedPassword
    }
  };

  return js2xml.buildObject(login);
};

utilities.SHA256andBase64 = function(text) {
  return new Buffer(
    crypto.createHash('sha256')
    .update(text)
    .digest('hex'),
  'utf-8').toString('base64');
};
